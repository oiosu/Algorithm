### ✔코드리뷰 

#### [오목]

```python
#카카오 코테에서 2번 문항으로 나올 수 있는 기출 문제이다.  
#그만큼 난이도가 있는 문제였다. 

#가로 세로가 19 로 고정이 되었고, BLACK, WHITE 로 변수 설정 
#검은색 WIN = 1, 흰색 WIN = 2, NOT = 0

#⭐ 델타탐색

델타_Y = [0, 1, 1, -1]
# 우 하 우하 우상
델타_X = [1, 0, 1, 1]
Y = 2
X = 2
for d in range(4):
    next_y = y + 델타_y[d]
    next_x = x + 델타_x[d]
    
    while True:
        #조건1 범위를 벗어나면 안된다. (인덱스 범위 조건)
        if not(-1 < next_y < N and -1 < next_x < N):
            break
        
        #조건2 같은 색 돌이 나와야 한다. (돌 색깔 조건)
        if board[next_y][next_x] != board[y][x]:
            break
        
        #같은 색 돌 +1
        count += 1
        
        #다음 좌표 탐색 
        next_y = y + 델타_y[d]
        next_x = x + 델타_x[d]
```

```python
# 최종 코드 

# 상 => y -=1
#하 => y += 1


# 우 하 우상 우하
dy = [0, 1, -1, 1]
dx =[1, 0, 1, 1]
black = 1
white = 2
N = 19

board = []

#오목판 상황 입력
for _ in range(N):
    temp_list = list(map(int, input().split()))
    board.append(temp_list)
    
#pprint(board)

answer= 0
#이중 반복문 
for y in range(N):
    for x in range(N):
        #델타 탐색
        for d in range(4):
            #방향이 바뀔 때마다 돌의 개수가 갱신(0)
            stone_count = 0
            #다음 좌표 탐색 
            ny = y +dy[d]
            nx = x +dy[d]
            
            while True:
                #인덱스 조건 
                if not(-1 ny < N and -1 < nx < N):
                    break
                # 같은색(값) 돌인지 확인하는 조건
                if not(board[y][x] == board[ny][nx]):
                    break
                    
                #같은 값이고 범위를 벗어나지 않으면 
                stone_count += 1
                
                #같은 밯양 다음 좌표를 탐색 
                ny = ny +dy[d]
                nx = nx +dx[d]
           #돌의 개수가 5개라면 
           if stone_count == 5:
                #이전 좌표 
                prev_y = y - dy[d]
                prev_x = x - dx[d]
                
                #육목인지 판단 
                #조건 1. 이전 좌표가 범위를 벗어나면 오목 
                if not(-1 < prev_y N and -1 < prev_x < N):
                    
                #조건 2. 기준 좌표의 값과 이전 좌표의 값이 다르면 오목 
                if board[y][x] =/= board[prev_y][prev_x]:
                    
                #조건1, 조건 2를 만족하면 오목이 완성 
                if not(-1 .....)
                    #answer 값 갱신 
                	answer = board[y][x]
                #현재 돌의 색 출력 
                print(board[y][x])

```



----

---



## 🔥 그래프 Graph 

정점vertex(=노드node)과 이를 연결하는 간선edge들의 집합으로 이루어진 **비선형 자료구조** 

> 소셜 네트워크와 지하철 노선도 같이, 현실에 있는 개체 간의 관계를 나타내기 위해 사용 

#### ◼ 그래프 관련 용어 

* **정점 vertex  (노드 node)** : 간선으로 연결되는 객체(사물의 표현)이다. 

* **간선 edge**: 정점 간의 관계(연결)를 표현하는 선을 의미한다. 

* **경로 path** : 시작 정점 부터 도착 정점까지 거치는 정점을 나열한 것을 의미한다. 

* **인접 adjacency** 두개의 정점이 하나의 간선으로 직접 연결된 상태를 의미한다. 

 

###  📌그래프의 종류 

**(1) 무방향 그래프** 

* 간선의 방향이 없는 가장 일반적인 그래프 

* 간선을 통해 양방향의 정점 이동 가능 

* 차수 degree 하나의 정점에 연결된 간선의 개수 

* 모두 정점의 차수의 합 = 간선 수 x 2



**(2) 유방향 그래프 (= 방향 그래프)**

* 간선의 방향이 있는 그래프 

* 방향이 있기 때문에 갈 수 있는 방향이 정해져 있다. 

* 간선의 방향이 가리키는 정점으로 이동 가능 

* 차수 degree : 진입  차수와 진출 차수로 나누어짐 

  * 진입차수_들어오는, 받아오는 (in-degree) : 외부 정점에서 한 정점으로 들어오는 간선의 수 

  * 진출차수 (out-degree) : 한 정점에서 외부 정점으로 나가는 간선의 수 





### 📌그래프의 표현

```python
#숫자이긴 하지만 인덱스로 표현이 가능 할 수 도 있을 것이라고 생각한다. 
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 4, 5],
    3: [1],
    4: [1, 2, 6],
    5: [2],
    6: [4]
}


# graph[0][0] => 1


graph = {
    [1, 2],
  	[0, 3, 4],
    [0, 4, 5],
    [1],
    [1, 2, 6],
    [2],
    [4]
}

# graph[0][0] => 1

```



* 인접 리스트 : 리스트를 통해 각 정점에 댛나 인접 정점들을 순차적으로 표현하는 방식 

* 인접행렬 : 두 정점을 연결하는 간선이 없으면 0 , 있으면 1을 가지는 행렬로 표현하는 방식 

=> 0을 기점으로 데칼코마니 같은 모습을 볼 수 있다. 

=> 무방향 



```python
edges = [
    [0, 1],
    [0, 2],
    [1, 3],
    [1, 4],
    [2. 4],
    [2, 5],
    [4, 6]
]

#set
#리스트 안에 리스트가 있는 형태라면 flatten
# flattne_edges = [0, 1, 0, 2, 1, 3 1, 4, 2, 4, 2, 5, 4, 6]

print(*edges)


```

```python
edges = [
    [0, 1],
    [0, 2],
    [1, 3],
    [1, 4],
    [2. 4],
    [2, 5],
    [4, 6]
]

n = 7
#n x n 행렬 초기화 [0으로 초기화 ]
matrix = [[0]*n for _ in range(n)]

```



**◼ 인접행렬과 인접 리스트 비교** 

```python
 # 인접 행렬 
graph = [
    [0, 1, 1, 0, 0, 0, 0],
    [1, 0, 0, 1, 1, 0, 0],
    [1, 0, 0, 0, 1, 1, 0],
    [0, 1, 0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 1],
    [0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0]
]
 
```

```python
# 인접 리스트
graph = [
    [1, 2],
    [0, 3, 4],
    [0, 4, 5],
    [1],
    [1, 2, 6],
    [2],
    [4]
]
```

**: 인접 행렬은 직관적이고 만들기 편하짐나, 불필요하게 공간이 낭비된다.** 

**: 인접 리스트는 연결된 정접만 저장하여 효율적이므로 자주 사용된다.** 











