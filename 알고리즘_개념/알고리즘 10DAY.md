### ✔코드리뷰 

### [박스]

```python
#박스를 이동하기 위해서는 어떤 것들이 있을까? 


#조건1) 현재 박스 아래에 박스가 없어야 한다. 

박스 = 1
빈공간 = 0
#좌표
Y, X = 2, 0
#현재 좌표 아래에 박스가 없어야 한다. 
if 박스_리스트[y+1][x] != 박스:
    
# 조건2) 박스는 바닥을 벗어나면 안된다 
=> 리스트의 범위를 벗어나면 안된다. 
#리슷트의 크기 
# m x n 
m, m = 5, 4
# 현박스는 바닥을 벗어나면 안된다. 
# 리스트의 범위를 벗어나면 안된다. 
if y + 1 != m:

#박스 이동 
현재 위치는 0 저장 아래 위치는 1저장 
#박스 = 1
#박스 = 0

# 현재 좌표 
y, x = 2, 0
# 박스 이동 
박스_리스트[y+1][x] = 박스 
박스_리스트[y][x] = 빈공간 

# 두조건을 and로 묶어서 while문으로 넣어주기 
```



```python
박스 = 1
빈공간 = 0

#현재 좌표 
y, x = 2, 0
#박스 이동
while 조건:
	박스_리스트[y+1][x] = 박스 
	박스_리스트[y][x] = 빈공간 
	y += 1
    
    
# 두조건을 and로 묶어서 while문으로 넣어주기 
while (박스_리스트[y+1][x] != 박스 and 박스_리스트[y][x] = 빈공간 )
```



```python
# 최종 

박스 = 1
빈공간 = 0

행_개수, 열_개수 = 5, 4
#밑에서 아래로 봐야한다. 

이동거리 = 0ㄹ
#이중반복문 
#열부터 순회 
for x in range(열_개수):
# 행순회 단, 아래에서 위로 탐색을 한다.
#  4 부터 -1 까지 (range는 마지막 값이 포함되지 않는다. )
	for y in range(m-1, -1, -1): #(m-1 행개수)
        
print(list(reverse([1,2,3])))


	for y in list(range(행_개수))[::-1]:
        # 만약에 현재 탐색하고(보고)있는 좌표에 박스가 있으면 
        if 박스_리스트[y][x] == 박스:
            #while 박스_리스트[y+1][x] != 박스 and y+1 != 행_개수: 오류발생
                박스_리스트[y][x] = 빈공간
                박스_리스트[y+1][x] = 박스
                y +=1
                이동거리 += 1
              	
            # 조건 1. 박스 아래에 박스가 없어야 한다. 
            if 박스_리스트[y+1][x] != 박스:
                
            #조건 2. 박스가 바닥을 벗어나면 안된다. 
            #리스트의 범위를 벗어나면 안된다. 
            if y+1 != 행개수:
```



#### *  범위가 가장 중요하다. 



### 델타 이동 or 델타 탐색 

>  한 좌표의 기준으로 4방위 상하 좌우 하는 것 

```python
# [0, 0, -1, 1] 이 겹치면 안된다. 
# 상하좌우 다 돌아야 하기 때문 

델타_y = [0, 0, 1, -1]
델타_x = [1, -1, 0, 0]
y, x = 1, 1
for d in range(4):
	탐색_y = y + 델타_y[d]
	탐색_x = x + 델타_x[d]
	print(탐색_y, 탐색_x)

```

```python
# 8개가 된다면 ? 

델타_y = [-1, -1, -1, 0, 0, 1, 1, 1]
델타_x = [-1, 0, 1, -1, 1, -1, 0, 1]
```



```python
#최종
#이중반복문
#지뢰발견 = false
for y in range(8):
    for x in rnage(8):
        #현재 위치가 오픈한 위치
        #오픈보드 =>  x
        if 오픈 보드[y][x] == "x":
            지뢰수 = 0 
        
        for d in range(8):
           탐색_y = y + 델타_y[d]
       	   탐색_x = x + 델타_x[d]
           #탐색_y 와 탐색_x의 범위는 리스트를 벗어나면 안된다. 라는 조건이 필요하다. 
           #리스트의 범위는 0 ~ 7(리스트의 길이 8)
           if 0<=탐색_y <= 8-1 and 0<=탐색_x <= 8-1:
           print(탐색_y, 탐색_x)
           if 게임보드[탐색_y][탐색_x] == 지뢰:
                지뢰수 += 1
        # 현재 오픈한 위치에 
```



---







